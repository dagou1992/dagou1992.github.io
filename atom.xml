<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dagou&#39;s Notes</title>
  
  <subtitle>你，是自在如风的少年。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-29T09:49:37.836Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jinbangqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Puppeteer爬虫初探</title>
    <link href="http://yoursite.com/2019/03/29/Puppeteer%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/03/29/Puppeteer爬虫初探/</id>
    <published>2019-03-29T08:03:51.000Z</published>
    <updated>2019-03-29T09:49:37.836Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/03/29/Puppeteer爬虫初探/project.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天发现了一个很好玩的node库，Puppeteer，准备玩一下。先来看看官方的介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。换句话说，它最大的特点就是它的操作Dom可以完全在内存中进行模拟既在V8引擎中处理而不打开浏览器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么 Puppeteer可以用来做什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以生成页面PDF文件；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动提交表单，进行 UI 测试，键盘输入等；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建一个时时更新的自动化测试环境。 使用最新的 JavaScript； 和浏览器功能直接在最新版本的Chrome中执行测试；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;捕获网站的 timeline trace，用来帮助分析性能问题；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试浏览器扩展；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这么多优秀的功能，简直是前端神器。&lt;/p&gt;
&lt;p&gt;Puppeteer 因为需要使用 async / await，所以尽量保证Node的版本在v7.6.0以上。&lt;/p&gt;
&lt;p&gt;本文主要拿它的爬虫功能玩一玩。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>深刻理解Node特性</title>
    <link href="http://yoursite.com/2018/08/31/%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3Node%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/08/31/深刻理解Node特性/</id>
    <published>2018-08-31T08:03:51.000Z</published>
    <updated>2019-03-29T09:42:36.508Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/08/31/深刻理解Node特性/project.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、node架构&quot;&gt;&lt;a href=&quot;#一、node架构&quot; class=&quot;headerlink&quot; title=&quot;一、node架构&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>理解Javascript中的深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2018/08/29/%E7%90%86%E8%A7%A3Javascript%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/08/29/理解Javascript中的深拷贝和浅拷贝/</id>
    <published>2018-08-29T07:12:18.000Z</published>
    <updated>2018-08-29T07:25:41.969Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/29/理解Javascript中的深拷贝和浅拷贝/project.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、两种数据类型&quot;&gt;&lt;a href=&quot;#一、两种数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、两种数据类型&quot;&gt;&lt;/a&gt;一、两种数据类型&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先，得理解Javascript中有两种数据类型：&lt;strong&gt;基本数据类型&lt;/strong&gt;和&lt;strong&gt;引用数据类型&lt;/strong&gt;。基本数据类型保存在栈内存中，引用数据类型保存在堆内存中。那么，为什么会有这样子的保存数据方式呢？保存在栈内存的必须是大小固定的数据，引用数据类型大小不固定，只能保存在堆内存中。所以在访问的时候，基本数据类型就是按值访问，操作的就是变量保存的值，访问引用类型的时候，只能访问保存在变量中的引用类型的&lt;strong&gt;地址&lt;/strong&gt;来操作实际对象。&lt;/p&gt;
&lt;h3 id=&quot;1、基本数据类型&quot;&gt;&lt;a href=&quot;#1、基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;1、基本数据类型&quot;&gt;&lt;/a&gt;1、基本数据类型&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;常见的基本数据类型包括：Number， String， Boolean，Null和Undefined，基本数据类型是按值访问的，所以可以直接操作保存在变量中的实际值，比如：&lt;br&gt;&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;//10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b); &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>10行代码实现页面无限滚动</title>
    <link href="http://yoursite.com/2018/08/28/10%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/08/28/10行代码实现页面无限滚动/</id>
    <published>2018-08-28T07:50:25.000Z</published>
    <updated>2018-08-28T09:06:17.925Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/28/10行代码实现页面无限滚动/project.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;由于网页的执行都是单线程的，在JS执行的过程中，页面会呈现阻塞状态。因此，如果JS处理的数据量过大，过程复杂，可能会造成页面的卡顿。传统的数据展现都以分页的形式，但是分页的效果并不好，需要用户手动点击下一页，才能看到更多的内容。有很多网站使用无限分页的模式，即网页视窗到达内容底部就自动加载下一部分的内容…&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h1&gt;&lt;p&gt;实现无限分页的过程大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 视窗滚动到底部；&lt;/li&gt;
&lt;li&gt;2 触发加载，添加到现有内容的后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，可能会出现两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 当页面的内容很少，没有出现滚动条；触发加载页面事件，直到加载到满足条件时停止加载；&lt;/li&gt;
&lt;li&gt;2 当页面的内容很多，出现了滚动条&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
